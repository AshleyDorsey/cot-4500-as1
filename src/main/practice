import numpy as np
import math

# Question 1: Use double precision, calculate the resulting values (format to 5 decimal places)
#       a) 0 | 10000000111 | 1110101110010000000000000000000000000000000000000000
# formula to use: (-1)^s*2^c-1027*(1 + f)

def binary_double_precision():
    # calculating the sign (s)
    binary_s = 0
    print(binary_s)

    # calculating the exponent (c)
    binary_exponent = 10000000111
    c = 0
    i = 0
    while(binary_exponent != 0):
        exp = binary_exponent % 10
        c = c + exp * pow(2, i)
        exponent = binary_exponent // 10
        i += 1
    print(c)

    # calculating the fraction (f)
    binary_fraction = str(1110101110010000000000000000000000000000000000000000)
    f = 0
    i = 1
    for item in binary_fraction:
        f = f + int(item) * ((1/2)**i)
        i += 1
    print(f)

    # formula for converting binary to decimal (n)
    n = ((-1)**binary_s)*(2**(c - 1023))*(1 + f)
    print(f"{n:.5f}")
    print("\n")

    # Question 2: Repeat question 1 using three-digit chopping arithmetic
    
    n = n * (10**-3)
    print((math.floor(n * 1000))/1000)
    print("\n")
    
    #Question 3: Repeat question 1 using three-digit rounding arithmetic
    
    n = n + 0.0005
    print(round(n, ndigits = 3))
    print("\n")
    
    # Question 4: Compute the absolute and relative error with the exact value form question 1 and its 3 digit rounding



# Question 5: What is the minimum number of terms needed to computer f(1) with error <10^-4?

def series_error():
    def infinite_series(x, k: int):
        return ((-1)**k) * ((x**k) / (k**3))
    
    minimum_error = 1e-4
    iteration_counter = 1

    while(abs(infinite_series(1, iteration_counter)) > minimum_error):
        iteration_counter += 1

    print(iteration_counter)

if __name__ == "__main__":
    print(binary_double_precision())
    #series_error()